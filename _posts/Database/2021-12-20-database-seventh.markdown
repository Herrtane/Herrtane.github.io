---
layout: post
title: <Database> 11. 트랜잭션 (완결)
date: 2021-12-20 23:50:23 +0900
category: Database
comments: true
---

## 트랜잭션 (transaction) 

- 트랜잭션 : 데이터베이스 어플리케이션에서 하나의 논리적인 단위를 수행하는 데이터베이스 연산들의 모임.
- 기업의 DBMS는 동시에 여러 사용자의 요청을 처리하므로, 운영체제가 다수의 프로그램들을 동시에 수행하듯이 여러 트랜잭션들을 동시에 수행해야 함. 

### 특성 

- 트랜잭션은 아래의 네 가지 특성을 만족해야 함.
1. 원자성 (Atomicity) : all or nothing
2. 일관성 (Consistency) : 트랜잭션의 수행 전후에 데이터베이스는 각각 일관된 상태를 지님.
3. 고립성 (Isolation) : 한 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 해야 함.
4. 지속성 (Durability) : 한 트랜잭션이 완료되면, 이 트랜잭션이 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않음. 

### SQL 구문 

- COMMIT, ROLLBACK : 각각 트랜잭션에서 변경하려는 내용이 데이터베이스에 완전하게 반영되었는지 일부만 되었는지에 따라 DBMS는 다르게 관리. 

## 동시성 제어 (concurrency control) 

- 마치 운영체제에서 mutex와 유사한 기능을 한다고 생각함.
- 비직렬스케쥴 (non-serial schedule)의 결과를 직렬 가능(serializable)하게 만드는 것.
- 동시성 제어를 하지 않고 다수의 트랜잭션을 동시에 수행하면, 아래의 문제가 발생할 수 있음.
1. 갱신 손실 (lost update) : 다른 트랜잭션으로 인해 이전에 수행중인 트랜잭션의 갱신된 내용이 무효화 됨.
2. 오손 데이터 읽기 (dirty read) : 완료되지 않은 트랜잭션이 갱신한 데이터.
3. 반복할 수 없는 읽기 (unrepeatable read) : 한 트랜잭션이 동일한 데이터를 두 번 읽을 때 서로 다른 값을 읽는 것. 

### 로킹 (locking) 

- 각 트랜잭션이 수행을 시작하여 데이터 항목을 접근할 때마다 요청한 로크에 관한 정보는 로크 테이블 등에 유지됨.
- 독점 로크 (eXclusive lock) : 트랜잭션에서 갱신을 목적으로 데이터 항목을 접근할 때 요청하는 로크.
- 공유 로크 (Shared lock) : 트랜잭션에서 읽을 목적으로 데이터 항목을 접근할 때 요청하는 로크.
- 접근을 끝낸 후에는 로크를 해제함.
- 로크 양립성 행렬을 참고하기 바람.
- 2단계 로킹 프로토콜 (2=phase locking protocol) : 로크 확장 단계와 로크 수축 단계로 이루어짐. 로크 포인트는 한 트랜잭션에서 필요한 모든 로크를 걸어놓은 시점.
- 데드록 : OS와 동일한 내용 (교착 상태)
- 다중 로크 단위 (multiple granularity) : 적은 수의 투플을 접근하는 트랜잭션에 대해서는 투플을 로크 단위로, 한 릴레이션에 속하는 대부분의 투플들을 접근하는 트랜잭션에 대해서는 릴레이션을 로크 다위로 하는 것. 로크 단위가 작을 수록 오버헤드 증가하나, 동시성의 정도는 증가. 
- 팬텀 문제 (phantom problem) 

## 회복 (recovery) 

- 회복 모듈은 원자성과 지속성을 보장해야 함.
- 성능 향상을 위해 버퍼가 주기억 장치 내에 존재하는데, 버퍼는 디스크로부터 데이터를 읽거나 디스크에 데이터를 기록하는 비용을 최소화하기 위해서 완충 역할을 함. 이 버퍼에 트랜잭션이 갱신 사항을 반영했으나, 버퍼의 내용이 디스크에 기록되기 전에 고장이 발생할 수 있음. 
1. 고장이 발생하기 전에 트랜잭션이 완료 : REDO
2. 고장이 발생하기 전에 트랜잭션이 완료 못함 : UNDO
- 재해적 고장과 비재해적 고장 

### 로그를 사용한 즉시 갱신

- 로그를 유지하기 떄문에 생길 수 있는 성능 저하를 피하고, 데이터베이스와 로그가 동시 손상을 입느 것을 피하기 위해서, 일반적으로 전용 디스크에 로그를 저장함.
- 모든 트랜잭션 연산들에 대해 로그가 저장되며, 각 로그 레코드는 로그 순서 번호 (Log Sequence Number) 로 식별됨.
- 로그도 버퍼가 존재하여, 로그 버퍼가 꽉 차면 주기억 장치 내의 로그 버퍼에서 디스크의 로그로 출력함.
- 이중로그 (dual log) : 두 개의 저장장치에 로그를 중복 저장하는 것.
- 로그의 유형의 예시는 아래와 같음.
1. [Trans-ID, start]
2. [Trans-ID, old_value, new_value]
3. [Trans-ID, commit]
4. [Trans-ID, abort]

- 시스템이 다운되었을 경우, DBMS의 회복모듈이 로그를 검사하여,
1. [Trans-ID, start], [Trans-ID, commit]가 모두 존재하는 트랜잭션들은 REDO
2. [Trans-ID, commit]가 존재하지 않는 트랜잭션들은 UNDO
- 트랜잭션의 취소는 로그를 역방향으로 따라가면서 진행.

### 로그 먼저 쓰기 (Write-Ahead Logging)

- 데이터베이스 버퍼와 로그 버퍼 중 하나만이 디스크에 먼저 기록될 수 있음. 동시에는 불가함.
- 로그 버퍼가 먼저 기록되어야만이, 이후에 시스템이 다운되더라도 이전 값을 알 수 있음.

### 체크포인트 (chech point)

- 로그는 단지 데이터베이스의 어떤 항목이 어떤 값으로 변경되었는지만 기록하므로, 추가 정보 없이는 주기억 장치의 버퍼가 디스크에 기록되었는가를 식별할 수 없음. 따라서, 체크포인트를 별도로 두어서, 회복시 재수행할 트랜잭션 수를 줄여야함.
- 체크포인트를 수행하면 디스크 상에서 로그와 데이터베이스의 내용이 강제로 일치하게 되고, 로그에 [chechpoint] 로그가 기록됨.
- 체크포인트 이전에 수행 완료된 트랜잭션은 재수행할 필요가 없음.

## 마치며

드디어 데이터베이스에 대한 전반적인 포스팅을 마무리한다. 개인적인 소감으로는 데이터베이스를 독학하면서 내용이 참 흥미로웠다. 크게 무겁게 다가오지 않았고, 무엇보다도 MySQL과 PHPMyAdmin을 종종 다뤘던 경험이 있어서 그런지, 굉장히 친숙한 내용들이 많았다. 내가 알던 지식에 더 단단한 이론들을 얻을 수 있었던 것 같아서 뿌듯하다. 실전적인 공부는 직접 오라클과 MySQL 등을 다루면서 계속 진행해나갈 것이다.

<br/>

아마 다음 포스팅 카테고리는 몇달 전에 독학했었던 운영체제가 되지 않을까 싶다. 그때는 운영체제가 어떤 과목이길래 그렇게 중요하다고 하는지 정말 궁금한 마음에 독학을 시작했었는데, 어느덧 이렇게 많은 시간이 지나서 참 기분이 묘하다. 이렇게 하나하나 미리 공부해두면, 복학하고 학과 공부에서도 훨씬 큰 효과를 볼 수 있으리라 확신한다. 그럼, 다음 포스팅에서 다시 찾아뵙도록 하겠다.

<br/>

아, 2년전에 학교에서 배웠던 컴퓨터 아키텍쳐 과목을 먼저 복습할 겸 다룰수도 있을 것 같다. 추후에 정해지는대로 포스팅하도록 하겠다.