---
layout: post
title: <정보처리기사> 01. 소프트웨어 설계 (요구분석 및 설계)
date: 2022-03-07 01:10:23 +0900
category: InformationProcessing
comments: true
---

## 서론

이 포스팅을 작성하는 목적은 크게 네가지이다. 

1. 2달뒤에 있을 정보처리산업기사 실기를 위해 그동안 공부했던 내용을 총정리하는 목적으로 작성한다.
2. 4학년때 치를 정보처리기사 시험을 위해 정리해놓는다. (그런데 내년에 또 개정된다는 소문이 있다..)
3. 내가 졸업하고 실무를 진행할 때 알아두어야 할 실무의 흐름과 개념들을 미리 총정리한다.
4. 최근 따로 책을 사서 공부한 소프트웨어 공학 전공책을 이 참에 포스팅으로 정리한다.

프로그래밍 언어 활용, 데이터베이스, 운영체제, 자료구조 및 알고리즘, 네트워크 등 정보처리기사 나머지 과목들은 이미 전공 카테고리로 따로 정리했기 때문에 이곳에는 정리하지 않는다.

## SDLC (Software Development Life Cycle)

### Waterfall Model

- 타당성검토 > 계획 > 요구분석 > 설계 > 구현 > 테스트 > 유지보수
- 고전적, 선형적 모델
- 단계별 산출물이 명확하나, 중간에 요구사항 변경이 유연하지 않음.
    - 요구사항 개발 프로세스 : 도출 > 분석 > 명세화 > 확인 및 검증
    - 기능적 요구사항과 비기능적 요구사항으로 나뉨.

### Prototype Model

- 시제품을 만들어 최종 결과물을 예측
- 개발 중간에 요구사항 변경이 유연함.
- 인터페이스에 중점을 두어 개발.

### Spiral Model

- Waterfall 과 Prototype Model의 장점에 위험분석을 추가한 모형.
- 점진적 개발 과정의 반복으로 요구사항 추가가 가능함.
- 계획 및 정의 > 위험분석 > 개발 > 고객평가

### Agile Model

- 일정한 주기 (Sprint)를 반복하는 기능 중심 개발 모델.
- 변화에 유연한 모델.
- XP 모델링의 5가지 철학 : 의사소통, 피드백, 존중, 용기, 단순성
- Scrum 기법 사용 가능.
    - Scrum Master : 일일 회의 주관.
    - Product Owner : 요구사항이 담긴 Backlog를 작성
    - Sprint : 2~4주를 넘지 않도록 함.

## UML (Unified Modeling Language)

### UML의 구성 요소

- 사물
- 관계
    - 연관 (Association) : 의존과 비슷하나, 참조하는 객체나 클래스가 사용 후에도 유지된다는 차이가 존재.
    - 의존 (Dependency, 참조) : 클래스 간 객체 및 메서드 사용. 해당 객체는 사용 후 참조를 유지하지 않음.
    - 집합 (Aggregation) : 전체와 부분. 컴퓨터와 모니터, 키보드, 본체의 관계.
    - 일반화 (Generalization, 상속) : 상속 관계.
    - 실체화 (Realization, 구현) : 인터페이스를 구현받아 추상 메서드를 오버라이딩 하는 것.
- 다이어그램

### UML 다이어그램의 종류

- 구조적, 정적 다이어그램
    - 클래스 다이어그램
    - 객체 다이어그램
    - 컴포넌트 다이어그램 (구현 단계에서 사용)
    - 배치 다이어그램 (구현 단계에서 사용)
    - 복합체 구조 다이어그램
    - 패키지 다이어그램
- 행위, 동적 다이어그램
    - 유스케이스 다이어그램
    - 시퀀스 다이어그램
    - 상태 다이어그램
    - 액티비티 다이어그램
    - 커뮤니케이션 다이어그램
    - 인터렉션 개요 다이어그램
    - 타이밍 다이어그램
- 자주 사용되는 몇개의 다이어그램 (유스케이스, 시퀀스, 상태, 액티비티, 클래스, 객체)에 대해서는 더 자세히 다루어야 한다.

## 디자인 패턴 (Gang of Four)

- 모듈의 세분화된 역할이나, 모듈간의 인터페이스 구현 방식을 설계할 때 참조할 수 있는 전형적인 해결 방식.
- 디자인 패턴을 통해 설계 문제, 해결 방법, 해결 방법의 적용 시기, 그 결과 등을 알 수 있음.
- 아키텍쳐 패턴은 디자인 패턴보다 상위 수준의 설계에 사용되며, 아키텍쳐 패턴은 전체 시스템의 구조를 설계하기 위해 사용되고, 디자인 패턴은 서브 시스템에 속하는 컴포넌트 간의 관계를 설계하기 위해 사용됨.
- 목적에 따라 생성, 구조, 행동 3가지 패턴으로 구분할 수 있음.
- 생성 : 객체의 인스턴스 과정을 추상화하는 방법으로, 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 받지 않도록 하여 프로그램의 유연성을 더해줌.
- 생성 패턴 종류 (5가지) : Abstract Factory, Builder, Factory Method, Prototype, Singleton
- 구조 : 클래스나 객체들을 조합해 더 큰 구조로 만들 수 있게 해줌.
- 구조 패턴 종류 (7가지) : Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy
- 행위 : 클래스나 객체들이 서로 상호작용하는 방법이나, 어떤 알고리즘을 어떤 객체에 할당하는 것이 좋을지 정의.
- 행위 패턴 종류 (11가지) : Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor
- 각 패턴들의 상세 설명은 생략. (단, 시험 전에 반드시 정리하고 가자.)

## 객체지향

### 객체지향분석 (OOA)

- 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스 (객체), 이와 연관된 속성과 연산, 그들 간의 관계 등을 정의하여 모델링하는 작업.
- Rumbaugh 방법 : 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링. 객체 모델링 기법이라고도 함. 객체 모델링 (객체 다이어그램) > 동적 모델링 (상태 다이어그램) > 기능 모델링 (DFD) 순으로 이루어짐.
- Boock 방법 : Micro + Macro 개발 프로세스를 사용.
- Jacobson 방법 : Use Case를 강조하여 사용.
- Coad - Yourdon 방법 : E-R 다이어그램을 사용하여 객체의 행위를 모델링.
- Wirfs - Brock 방법 : 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행.

### 객체지향설계원칙 (SOLID)

- SRP (Single Responsibility Principle) : 한 클래스는 하나의 책임만 져야 한다. 응집도는 높이고, 결합도는 낮춘다. 
- OCP (Open - Closed Principle) : 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다.
- LSP (Liskov Substitution Principle) : 자식클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야 한다.
- ISP (Interface Segregation Principle) : 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다 여러개의 구체적인 인터페이스가 낫다는 뜻이며, 자신이 사용하지 않는 기능 (인터페이스)에는 영향을 받지 말아야 한다는 뜻이다.
- DIP (Dependency Inversion Principle) : 의존관계를 맺을 때, 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺어야 한다.
- Demeter's Law : '친한 친구하고만 이야기하라.' = 동일한 객체 내의 메소드 및 속성을 주로 사용해야 한다.

## UI (User Interface)

### UI 설계의 기본원칙

- 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 함.
- 유효성 : 사용자의 목적을 정확히 달성해야 함.
- 학습성 : 쉽게 배우고 익힐 수 있어야 함.
- 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함.

### UI 설계 도구

- Wireframe : 레이아웃을 협의하고 공유하기 위해 사용
- Story Board : 최종적으로 참고하는 작업 지침서, 산출물
- Prototype : 실제 구현된 것 처럼 테스트가 가능한 동적인 모형
- Mockup : 실제 화면과 유사한 정적인 모형
- Use Case : 사용자 측면 요구사항을 다이어그램으로 묘사

## 품질 요구사항

### ISO/IEC 9126

- 기능성 (Functionality) : 요구사항을 정확히 만족하는 기능을 수행하는지
- 신뢰성 (Reliability) : 기능을 오류없이 수행하는지
- 사용성 (Usability) : 사용자가 정확히 이해하고 사용하는지
- 효율성 (Efficiency) : 한정된 시간과 자원으로 얼마나 효율적으로 처리하는지
- 유지보수성 (Maintainability) : 쉽게 개선하고 확장하고 보수할 수 있는지
- 이식성 (Portability) : 다른 환경에서도 쉽게 적용할 수 있는지

### ISO/IEC 12207 

- 기본 프로세스
- 조직 프로세스
- 지원 프로세스

### ISO/IEC 15504 (SPICE)

- 불완전 (Lv.0) > 수행 (Lv.1) > 관리 (Lv.2) > 확립 (Lv.3) > 예측가능 (Lv.4) > 최적화 (Lv.5)

### CMMI (Capability Maturity Model Integration)

- 성숙도와 능력도를 평가하는 모델
- 초기 > 관리 > 정의 > 정량적 관리 > 최적화

## 아키텍쳐

### 소프트웨어 아키텍쳐

- 모듈화 : 적절한 모듈의 크기를 찾는 것이 중요함. 모듈의 크기가 크면 모듈 하나의 개발비용이 크고, 모듈의 크기가 작으면 모듈간 통합 비용이 큼.
- 추상화 : 전체적이고 포괄적인 개념을 설계한 후, 세분화하고 구체화하는 것. 과정, 데이터, 제어 추상화가 있음.
- 단계적 분해 : 하향식
- 정보 은닉

### 아키텍쳐 패턴

- 계층 패턴
- 파이프필터 패턴
- 클라이언트-서버 패턴
- MVC 패턴 : Model은 데이터보관, View는 사용자에게 정보 표시, Controller는 입력처리. 대화형 어플리케이션에 적합.
- 마스터-슬레이브 패턴
- 브로커 패턴
- 피어투피어 패턴

### 아키텍쳐 뷰

- 소프트웨어 아키텍쳐 4+1 뷰 : 고객의 요구사항을 정리해놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법. 4개의 분리된 구조로 구성되는 아키텍쳐 개념을 제시하고, 이 4개의 구조가 서로 충돌되지 않는지, 요구사항을 충족하는지 증명하기 위한 체크 방법으로 Usecase를 사용함.
- 4+1에서 1은 Usecase View 이고 (중앙), 나머지 4개는 Logical View, Process View, Deployment View, Implementation View 이다.
- Usecase View : 다른 뷰를 검증하는 데 사용. 사용자, 설계자, 개발자, 테스트 관점. 유스케이스 다이어그램 사용.
- Logical View : 시스템 내부를 조망하고 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명. 설계자, 개발자 관점. 
- Process View : 시스템의 비기능적인 요구사항인 자원 효율성, 병행 실행, 비동기, 이벤트 처리 등을 고려. 개발자와 시스템 통합자 관점.
- Implementation View : 독립적으로 실행되는 컴포넌트와 이들간 관계를 정의. 
- Deployment View : 다양한 실행파일 및 런타임 컴포넌트가 해당 플랫폼 또는 노드 등의 물리적인 아키텍쳐에 어떻게 배치되는가를 보여줌. 개발자, 시스템 통합자, 테스터 관점. 배치 다이어그램 사용.

## 결합도와 응집도

### 결합도 (Coupling)

- 결합도는 낮을수록 좋음.
- 내용 (Content) : 모듈간 직접 참조
- 공유 (Common) : 모듈간 전역 변수 사용
- 외부 (External) : 한 모듈의 변수를 외부에서 다른 모듈이 참조
- 제어 (Control) : 모듈간 제어를 위한 제어 신호, 제어 요소를 전달
- 스탬프 (Stamp) : 모듈간 자료구조 전달
- 자료 (Data) : 모듈간 매개변수로 데이터 전달

### 응집도 (Cohesion)

- 응집도는 높을수록 좋음.
- 우연적 (Coincidental) : 모듈 내 요소들이 서로 아무 연관이 없음
- 논리적 (Logical) : 모듈 내 요소들이 특정 형태를 갖거나 유사한 성격을 가짐
- 시간적 (Temporal) : 특정 시간에 요소들이 수행됨
- 절차적 (Procedural) : 모듈 내 요소들이 순차적으로 (주의) 수행됨
- 통신적 (Communication) : 요소들이 동일한 입출력으로 서로 다른 기능을 수행
- 순차적 (Sequential) : 모듈의 출력값을 다시 입력값으로 사용
- 기능적 (Functional) : 모든 요소들이 하나의 기능을 위해 모임

## 코드

- 순차코드, 블록코드, 10진코드, 그룹분류코드, 표의숫자코드, 연상코드, 합성코드 

## 개발 기술 환경

- OS : 하드웨어가 아닌 소프트웨어
- 미들웨어 : OS와 응용 소프트웨어 사이에서 추가적인 서비스를 제공하는 소프트웨어.
- DBMS : DB를 관리하는 소프트웨어
- WAS (Web Application Server) : 웹서버와는 다르게 동적 컨텐츠를 처리하는 미들웨어. Tomcat, JEUS, WebSphere, JBoss, WebLogic 등이 있음.
- Open Source

### 미들웨어 솔루션의 종류

- RPC (Remote Proceduce Call) : 원격 프로시저 호출 미들웨어.
- MOM (Message Oriented Middleware) : 메시지 기반 비동기형 메시지를 전달하는 미들웨어.
- DB
- TP Monitor : 빠른 응답속도가 필요한 업무에 사용되는 트랜잭션 처리 및 감시 미들웨어. 항공기나 철도 예약 업무 등에 최적.
- Legacyware
- ORB (Object Request Broker) : CORBA 표준 스펙을 구현한 객체지향 미들웨어. 분산 시스템 관련 표준 사용.
- WAS

## 인터페이스

### 인터페이스 요구사항 검증

- 인터페이스 요구사항 검토 계획 수립 > 검토 및 오류 수정 > 베이스라인 설정
- 동료 검토 (Peer Review)
- 워크 스루 (Walk Through) : 검토 회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후, 짧은 검토 회의를 통해 결함을 발견하는 검토 방법.
- 인스펙션 (Inspection) : 다른 검토 전문가들이 확인하면서 결함을 발견하는 검토 방법.

### 인터페이스 표준 항목

- 시스템 공통부 : 시스템 간 연동시 필요한 공통 정보. (인터페이스 ID, 전송 시스템, 서비스 코드, 응답 결과, 장애 관련 정보)
- 거래 공통부 : 시스템들이 연동된 후, 송,수신되는 데이터를 처리할 때 필요한 정보. (직원, 승인자, 기기, 매체 관련 정보)

### 시스템 연계 기술

- 직접 연계 방식
    - DB 링크 (DB link)
    - DB 연결 (DB Connection)
    - API/Open API
    - JDBC
    - Hyper Link : href 이용
    - EAI
- 간접 연계 방식
    - 소켓
    - 웹 서비스 : WSDL, UDDI, SOAP 프로토콜을 이용해 연계하는 서비스.
        - WSDL (Web Services Description Language) : 웹 서비스와 관련된 서식, 위치, 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 XML 기반 언어.
        - UDDI (Universal Description, Discovery and Integration) : 인터넷 전세계 비즈니스 업체 목록에 자신의 목록을 등록하기 위한 XML 기반의 규격.
        - SOAP (Simple Object Access Protocol) : 웹 서비스를 실제로 이용하기 위한 객체 간의 통신 규약. 주로 기업에서 이용. (RESTful은 XML, JSON을 사용한 가벼운 아키텍쳐인 반면, SOAP는 WSDL을 사용한 무거운 프로토콜임.)
    - ESB

### 인터페이스 통신 유형

- 단방향 : 거래 요청만 하고 응답은 없는 방식.
- 동기 (Sync) : 거래 요청 후 응답이 올 때 까지 대기 (Request-Reply)하는 방식.
- 비동기 (Async) : 거래 요청 후 다른 작업을 수행하다 응답이 오면 처리하는 방식.

### 인터페이스 처리 유형

- 실시간 방식 : 요청 내용을 바로 처리해야 할 때 사용.
- 지연 처리 방식 : 매 건 단위 처리로 비용이 많이 발생할 때 사용.
- 배치 방식 (Batch, 일괄처리) : 대량의 데이터를 처리할 때 사용.

### 데이터 통신을 이용한 인터페이스 구현

- 인터페이스 형식에 맞춘 데이터 포맷을 인터페이스 대상으로 전송, 수신측에서는 이를 Parsing해 해석하는 방식.
- 주로 JSON이나 XML 형식의 데이터 포맷을 사용해 인터페이스 구현.
    - JSON (JavaScript Object Notation) : Attribute-Value Pairs로 이루어진 데이터 객체를 전달하기 위해, 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷.
    - XML (eXtensible Markup Language) : 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어. HTML의 호환성 문제와 SGML (Standard Generalized Markup Language)의 복잡성 문제를 해결하기 위해 개발됨. SGML의 간략화된 버전.

### 인터페이스 구현 검증 도구

- xUnit : 다양한 언어를 지원하는 단위 테스트 프레임워크
- STAF : 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
- FitNesse : 웹 기반 테스트 프레임워크
- NTAF : STAF의 재사용, 확장성 + FitNesse의 협업 기능. Naver의 테스트 자동화 프레임워크
- Selenium : 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 (WA) 테스트 프레임워크
- watir : Ruby 언어를 사용하는 애플리케이션 테스트 프레임워크