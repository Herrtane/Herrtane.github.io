---
layout: post
title: <정보처리기사> 01. 소프트웨어 설계 (요구분석 및 설계)
date: 2022-03-07 01:10:23 +0900
category: InformationProcessing
comments: true
---

## 서론

이 포스팅을 작성하는 목적은 크게 네가지이다. 

1. 2달뒤에 있을 정보처리산업기사 실기를 위해 그동안 공부했던 내용을 총정리하는 목적으로 작성한다.
2. 4학년때 치를 정보처리기사 시험을 위해 정리해놓는다. (그런데 내년에 또 개정된다는 소문이 있다..)
3. 내가 졸업하고 실무를 진행할 때 알아두어야 할 실무의 흐름과 개념들을 미리 총정리한다.
4. 최근 따로 책을 사서 공부한 소프트웨어 공학 전공책을 이 참에 포스팅으로 정리한다.

프로그래밍 언어 활용, 데이터베이스, 운영체제, 자료구조 및 알고리즘, 네트워크 등 정보처리기사 나머지 과목들은 이미 전공 카테고리로 따로 정리했기 때문에 이곳에는 정리하지 않는다.

## SDLC (Software Development Life Cycle)

### Waterfall Model

- 타당성검토 > 계획 > 요구분석 > 설계 > 구현 > 테스트 > 유지보수
- 고전적, 선형적 모델
- 단계별 산출물이 명확하나, 중간에 요구사항 변경이 유연하지 않음.
    - 요구사항 개발 프로세스 : 도출 > 분석 > 명세화 > 확인 및 검증
    - 기능적 요구사항과 비기능적 요구사항으로 나뉨.

### Prototype Model

- 시제품을 만들어 최종 결과물을 예측
- 개발 중간에 요구사항 변경이 유연함.
- 인터페이스에 중점을 두어 개발.

### Spiral Model

- Waterfall 과 Prototype Model의 장점에 위험분석을 추가한 모형.
- 점진적 개발 과정의 반복으로 요구사항 추가가 가능함.
- 계획 및 정의 > 위험분석 > 개발 > 고객평가

### Agile Model

- 일정한 주기 (Sprint)를 반복하는 기능 중심 개발 모델.
- 변화에 유연한 모델.
- XP 모델링의 5가지 철학 : 의사소통, 피드백, 존중, 용기, 단순성
- Scrum 기법 사용 가능.
    - Scrum Master : 일일 회의 주관.
    - Product Owner : 요구사항이 담긴 Backlog를 작성
    - Sprint : 2~4주를 넘지 않도록 함.

## UML (Unified Modeling Language)

### UML의 구성 요소

- 사물
- 관계
    - 연관 (Association) : 의존과 비슷하나, 참조하는 객체나 클래스가 사용 후에도 유지된다는 차이가 존재.
    - 의존 (Dependency, 참조) : 클래스 간 객체 및 메서드 사용. 해당 객체는 사용 후 참조를 유지하지 않음.
    - 집합 (Aggregation) : 전체와 부분. 컴퓨터와 모니터, 키보드, 본체의 관계.
    - 일반화 (Generalization, 상속) : 상속 관계.
    - 실체화 (Realization, 구현) : 인터페이스를 구현받아 추상 메서드를 오버라이딩 하는 것.
- 다이어그램

### UML 다이어그램의 종류

- 구조적, 정적 다이어그램
    - 클래스 다이어그램
    - 객체 다이어그램
    - 컴포넌트 다이어그램 (구현 단계에서 사용)
    - 배치 다이어그램 (구현 단계에서 사용)
    - 복합체 구조 다이어그램
    - 패키지 다이어그램
- 행위, 동적 다이어그램
    - 유스케이스 다이어그램
        - 구성요소 : 시스템, 액터, 유스케이스 (사용자가 기대하는 시스템의 기능), 관계
        - 관계 : 연관, 의존, 일반화
        - 의존관계는 다시 포함 (Include), 확장 (Extend) 으로 나뉨.
        - 포함 (Include) : 반드시 실행되어야 하는 경우.
        - 확장 (Extend) : 특정 조건을 만족, 필요로 하는 경우.
    - 시퀀스 다이어그램
    - 상태 다이어그램
    - 액티비티 다이어그램
    - 커뮤니케이션 다이어그램
    - 인터렉션 개요 다이어그램
    - 타이밍 다이어그램
- 자주 사용되는 몇개의 다이어그램 (유스케이스, 시퀀스, 상태, 액티비티, 클래스, 객체)에 대해서는 더 자세히 다루어야 한다.

## 디자인 패턴 (Gang of Four)

- 모듈의 세분화된 역할이나, 모듈간의 인터페이스 구현 방식을 설계할 때 참조할 수 있는 전형적인 해결 방식.
- 디자인 패턴을 통해 설계 문제, 해결 방법, 해결 방법의 적용 시기, 그 결과 등을 알 수 있음.
- 아키텍쳐 패턴은 디자인 패턴보다 상위 수준의 설계에 사용되며, 아키텍쳐 패턴은 전체 시스템의 구조를 설계하기 위해 사용되고, 디자인 패턴은 서브 시스템에 속하는 컴포넌트 간의 관계를 설계하기 위해 사용됨.
- 목적에 따라 생성, 구조, 행동 3가지 패턴으로 구분할 수 있음.
- 생성 : 객체의 인스턴스 과정을 추상화하는 방법으로, 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 받지 않도록 하여 프로그램의 유연성을 더해줌.
- 생성 패턴 종류 (5가지) : Abstract Factory, Builder, Factory Method, Prototype, Singleton
- 구조 : 클래스나 객체들을 조합해 더 큰 구조로 만들 수 있게 해줌.
- 구조 패턴 종류 (7가지) : Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy
- 행위 : 클래스나 객체들이 서로 상호작용하는 방법이나, 어떤 알고리즘을 어떤 객체에 할당하는 것이 좋을지 정의.
- 행위 패턴 종류 (11가지) : Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor
- 각 패턴들의 상세 설명은 생략. (단, 시험 전에 반드시 정리하고 가자.)

## 객체지향

### 객체지향분석 (OOA)

- 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스 (객체), 이와 연관된 속성과 연산, 그들 간의 관계 등을 정의하여 모델링하는 작업.
- Rumbaugh 방법 : 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링. 객체 모델링 기법이라고도 함. 객체 모델링 (객체 다이어그램) > 동적 모델링 (상태 다이어그램) > 기능 모델링 (DFD) 순으로 이루어짐.
- Booch 방법 : Micro + Macro 개발 프로세스를 사용.
- Jacobson 방법 : Use Case를 강조하여 사용.
- Coad - Yourdon 방법 : E-R 다이어그램을 사용하여 객체의 행위를 모델링.
- Wirfs - Brock 방법 : 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행.

### 객체지향설계원칙 (SOLID)

- SRP (Single Responsibility Principle) : 한 클래스는 하나의 책임만 져야 한다. 응집도는 높이고, 결합도는 낮춘다. 
- OCP (Open - Closed Principle) : 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다.
- LSP (Liskov Substitution Principle) : 자식클래스는 부모클래스에서 가능한 행위를 수행(치환)할 수 있어야 한다. 즉, 상속을 의미한다.
- ISP (Interface Segregation Principle) : 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다 여러개의 구체적인 인터페이스가 낫다는 뜻이며, 자신이 사용하지 않는 기능 (인터페이스)에는 영향을 받지 말아야 한다는 뜻이다.
- DIP (Dependency Inversion Principle) : 의존관계를 맺을 때, 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺어야 한다. 즉, 변화하기 쉬운 것보다 변화하지 않는 것에 의존해야 한다.
- Demeter's Law : '친한 친구하고만 이야기하라.' = 동일한 객체 내의 메소드 및 속성을 주로 사용해야 한다.

## UI (User Interface)

### UI 설계의 기본원칙

- 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 함.
- 유효성 : 사용자의 목적을 정확히 달성해야 함.
- 학습성 : 쉽게 배우고 익힐 수 있어야 함.
- 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함.

### UI 설계 도구

- Wireframe : 기획 단계의 초기에 제작. 페이지에 대한 개략적인 레이아웃과 뼈대를 협의하고 공유하기 위해 사용.
- Mockup : wireframe보다 좀 더 실제 화면과 유사하게 만든 정적인 모형.
- Story Board : wireframe에 컨텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가한 문서. 최종적으로 참고하는 작업 지침서.
- Prototype : wireframe이나 story board등에 인터렉션을 적용함으로써, 실제 구현된 것 처럼 테스트가 가능한 동적인 모형. paper prototype과 digital prototype으로 나뉨.
- Use Case : 사용자 측면 요구사항을 다이어그램으로 묘사.

## 품질 요구사항

### ISO/IEC 9126

- 기능성 (Functionality) : 요구사항을 정확히 만족하는 기능을 수행하는지
- 신뢰성 (Reliability) : 기능을 오류없이 수행하는지
- 사용성 (Usability) : 사용자가 정확히 이해하고 사용하는지
- 효율성 (Efficiency) : 한정된 시간과 자원으로 얼마나 효율적으로 처리하는지
- 유지보수성 (Maintainability) : 쉽게 개선하고 확장하고 보수할 수 있는지
- 이식성 (Portability) : 다른 환경에서도 쉽게 적용할 수 있는지

### ISO/IEC 12207 

- ISO/IEC 9126은 품질에 관련된 사항만 다루고, 소프트웨어 프로세스 평가에 대한 사항은 다루지 않았기에, 해당 사항에 대한 체계적인 규정을 제시할 필요성이 대두되어 만들어진 개념. ISO/IEC 12207에서는 What을, ISO/IEC 15504에서는 How를 다룸.
- 3개의 생명주기 프로세스, 17개의 세부 프로세스, 74개의 활동 및 224개의 세부 활동으로 구성.
- 기본 프로세스 : 획득 > 공급 > 개발 > 운영 > 유지보수
- 조직 프로세스 : 기반구조, 관리, 개선, 훈련
- 지원 프로세스 : 문서화, 품질보증, 형상관리, 검증, 확인, 문제해결, 합동검토, 감사

### ISO/IEC 15504 (SPICE)

- ISO/IEC 12207를 기본 틀로하여, 12207의 프로세스를 평가하고 개선할 목적으로 고안됨.
- 불완전 (Lv.0) > 수행 (Lv.1) > 관리 (Lv.2) > 확립 (Lv.3) > 예측가능 (Lv.4) > 최적화 (Lv.5)

### CMMI (Capability Maturity Model Integration)

- 성숙도와 능력도를 평가하는 모델
- 초기 > 관리 > 정의 > 정량적 관리 > 최적화

## 아키텍쳐

### 소프트웨어 아키텍쳐 설계의 기본 원리

- 모듈화 : 적절한 모듈의 크기를 찾는 것이 중요함. 모듈의 크기가 크면 모듈 하나의 개발비용이 크고, 모듈의 크기가 작으면 모듈간 통합 비용이 큼.
- 추상화 : 전체적이고 포괄적인 개념을 설계한 후, 세분화하고 구체화하는 것. 즉, 구체화를 위한 사전 단계. 구성 요소로는 과정, 데이터, 제어 추상화가 있음.
    - 과정 추상화 : 프로세스 추상화, 자세한 수행 과정을 정의하지 않고 전반적인 흐름만 파악할 수 있게 설계하는 방법. 구조적 프로그래밍 언어에서 개발자는 코드를 줄 단위가 아닌 함수 단위로 접근하여 프로그래밍이 한결 수월해짐.
    - 데이터 추상화 : 데이터의 세부적 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 것.
    - 제어 추상화 : 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 것.
- 단계적 분해 : 추상화를 통해 단계적 분해를 진행할 수 있음. 추상화를 반복할 수록 더 구체적인 분해가 가능하며, 이를 하향식 구체화라고 함.
- 정보 은닉 : 추상화 > 단계적 분해까지 모듈화가 진행되었다면, 마지막으로 각각의 모듈이 서로 접근할 수 없도록 정보은닉이 진행됨. 이를 통해 각각의 모듈의 유지보수에 굉장한 이점이 있음.

### 아키텍쳐 패턴

- 계층 패턴
- 파이프필터 패턴
- 클라이언트-서버 패턴
- MVC 패턴 : Model은 데이터보관, View는 사용자에게 정보 표시, Controller는 입력처리. 대화형 어플리케이션에 적합.
- 마스터-슬레이브 패턴
- 브로커 패턴
- 피어투피어 패턴

### 아키텍쳐 뷰

- 소프트웨어 아키텍쳐 4+1 뷰 : 고객의 요구사항을 정리해놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법. 4개의 분리된 구조로 구성되는 아키텍쳐 개념을 제시하고, 이 4개의 구조가 서로 충돌되지 않는지, 요구사항을 충족하는지 증명하기 위한 체크 방법으로 Usecase를 사용함.
- 4+1에서 1은 Usecase View 이고 (중앙), 나머지 4개는 Logical View, Process View, Deployment View, Implementation View 이다.
- Usecase View : 다른 뷰를 검증하는 데 사용. 사용자, 설계자, 개발자, 테스트 관점. 유스케이스 다이어그램 사용.
- Logical View : 시스템 내부를 조망하고 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명. 설계자, 개발자 관점. 
- Process View : 시스템의 비기능적인 요구사항인 자원 효율성, 병행 실행, 비동기, 이벤트 처리 등을 고려. 개발자와 시스템 통합자 관점.
- Implementation View : 독립적으로 실행되는 컴포넌트와 이들간 관계를 정의. 
- Deployment View : 다양한 실행파일 및 런타임 컴포넌트가 해당 플랫폼 또는 노드 등의 물리적인 아키텍쳐에 어떻게 배치되는가를 보여줌. 개발자, 시스템 통합자, 테스터 관점. 배치 다이어그램 사용.

## 모듈의 품질 : 결합도와 응집도

### 결합도 (Coupling)

- 결합도는 낮을수록 좋음.
- 내용 (Content) : 모듈간 직접 참조
- 공유 (Common) : 모듈간 전역 변수 사용
- 외부 (External) : 한 모듈의 변수를 외부에서 다른 모듈이 참조
- 제어 (Control) : 모듈간 제어를 위한 제어 신호, 제어 요소를 전달
- 스탬프 (Stamp) : 모듈간 자료구조 전달
- 자료 (Data) : 모듈간 매개변수로 데이터 전달

### 응집도 (Cohesion)

- 응집도는 높을수록 좋음.
- 우연적 (Coincidental) : 모듈 내 요소들이 서로 아무 연관이 없음
- 논리적 (Logical) : 모듈 내 요소들이 특정 형태를 갖거나 유사한 성격을 가짐
- 시간적 (Temporal) : 특정 시간에 요소들이 수행됨
- 절차적 (Procedural) : 모듈 내 요소들이 순차적으로 (주의) 수행됨
- 통신적 (Communication) : 요소들이 동일한 입출력으로 서로 다른 기능을 수행
- 순차적 (Sequential) : 모듈의 출력값을 다시 입력값으로 사용
- 기능적 (Functional) : 모든 요소들이 하나의 기능을 위해 모임

## 코드

- 순차코드 (Sequence)
- 블록코드 (Block)
- 10진코드 (Decimal)
- 그룹분류코드 (Group Classification)
- 표의숫자코드 (Significant Digit)
- 연상코드 (Mnemonic)
- 합성코드 (Combined)

## 개발 기술 환경

- OS : 하드웨어가 아닌 소프트웨어
- 미들웨어 : OS와 응용 소프트웨어 사이에서 추가적인 서비스를 제공하는 소프트웨어.
- DBMS : DB를 관리하는 소프트웨어
- WAS (Web Application Server) : 웹서버와는 다르게 동적 컨텐츠를 처리하는 미들웨어. Tomcat, JEUS, WebSphere, JBoss, WebLogic 등이 있음.
- Open Source

## 인터페이스

### 인터페이스 요구사항 검증

- 인터페이스 요구사항 검토 계획 수립 > 검토 및 오류 수정 > 베이스라인 설정
- 요구사항 검토 : 검토 담당자들이 수작업으로 분석.
    - 동료 검토 (Peer Review)
    - 워크 스루 (Walk Through) : 검토 회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후, 짧은 검토 회의를 통해 결함을 발견하는 검토 방법.
    - 인스펙션 (Inspection) : 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 확인하면서 결함을 발견하는 검토 방법.
- 프로토타입 제작 : 시제품을 미리 만들어 최종 결과물을 예측.
- CASE 도구 활용 : 일관성 분석을 통해 요구사항 변경의 추적 및 분석, 관리, 표준 준수 여부 확인.
- 테스트 설계 : 테스트 케이스를 생성해 이후에 요구사항이 현실적으로 테스트 가능한지 검토.

### 인터페이스 송수신 데이터 식별

- 인터페이스는 서로 문제없이 상호작용하기 위한 도구이므로, 표준형식의 규격화된 송/수신 데이터가 흐름. 사람끼리 만났을 때 명함을 주고 받는 것과 비슷함.
- 교환되는 데이터 종류 : 인터페이스 표준 항목, 송수신 데이터 항목, 공통 코드
- 인터페이스 표준 항목 : 송수신 시스템을 연계하는데 표준적으로 필요한 데이터
    - 시스템 공통부 : 시스템 간 연동시 필요한 공통 정보. (인터페이스 ID, 전송 시스템, 서비스 코드, 응답 결과, 장애 관련 정보)
    - 거래 공통부 : 시스템들이 연동된 후, 송,수신되는 데이터를 처리할 때 필요한 정보. (직원, 승인자, 기기, 매체 관련 정보)
- 송수신 데이터 항목 : 송수신 시스템이 업무를 수행하는 데 사용하는 데이터. 전송되는 항목과 순서는 인터페이스별로 다름.
- 공통 코드 : 시스템들에서 공통적으로 사용하는 코드. 현재 상태나 오류에 대해 파악할 수 있도록 코드에 대한 정의와 설명이 되어 있는 것.

### 인터페이스 방법 명세화

- 내외부 시스템이 연계하여 작동할 때, 데이터를 주고 받는 방법, 데이터의 종류, 에러 발생 시 처리할 내용들을 문서로 명확하게 정리하는 것.
- 송수신 방법을 명세화하기 위해서는 시스템 연계 기술, 인터페이스 통신 유형, 처리 유형, 발생 주기 등에 대한 정보가 필요.
- 시스템 연계 기술 : 개발할 시스템과 내외부 시스템을 연계할 때 사용되는 기술
    - 직접 연계 방식
        - DB link : DB에서 제공하는 DB Link 객체를 이용하는 방식.
        - DB Connection
        - API/Open API
        - JDBC
        - Hyper Link : href 이용
        - 연계솔루션 : EAI 서버와 송수신 시스템에 설치되는 클라이언트를 이용하는 방식.
    - 간접 연계 방식
        - Socket : 서버는 통신을 위한 소켓을 생성해 포트를 할당하고, 클라이언트의 통신 요청 시 클라이언트와 연결하여 통신하는 네트워크 기술.
        - Web Service : WSDL, UDDI, SOAP 프로토콜을 이용해 연계하는 서비스.
            - WSDL (Web Services Description Language) : 웹 서비스와 관련된 서식, 위치, 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 XML 기반 언어.
            - UDDI (Universal Description, Discovery and Integration) : 인터넷 전세계 비즈니스 업체 목록에 자신의 목록을 등록하기 위한 XML 기반의 규격.
            - SOAP (Simple Object Access Protocol) : 웹 서비스를 실제로 이용하기 위한 객체 간의 통신 규약. 주로 기업에서 이용. (RESTful은 XML, JSON을 사용한 가벼운 아키텍쳐인 반면, SOAP는 WSDL을 사용한 무거운 프로토콜임.)
        - ESB
- 인터페이스 통신 유형 : 개발할 시스템과 내외부 시스템 간 데이터를 송수신하는 형태
    - 단방향 : 거래 요청만 하고 응답은 없는 방식.
    - 동기 (Sync) : 거래 요청 후 응답이 올 때 까지 대기 (Request-Reply)하는 방식.
    - 비동기 (Async) : 거래 요청 후 다른 작업을 수행하다 응답이 오면 처리하는 방식.
- 인터페이스 처리 유형 : 송수신 데이터를 어떻게 처리할 것인지에 대한 방식
    - 실시간 방식 : 요청 내용을 바로 처리해야 할 때 사용.
    - 지연 처리 방식 : 매 건 단위 처리로 비용이 많이 발생할 때 사용.
    - 배치 방식 (Batch, 일괄처리) : 대량의 데이터를 처리할 때 사용.
- 인터페이스 발생 주기

### 인터페이스 설계서 작성

### 미들웨어 솔루션

- 미들웨어는 서로 다른 두 서버 혹은 클라이언트 사이에서 요구되는 다양한 요청사항들을 서로에게 적합한 인터페이스로 변환하여 요청하고, 반환함으로써 원활하게 데이터가 오갈 수 있도록 도와주는 중계자의 역할을 수행.
- RPC (Remote Procedure Call) : 원격 프로시저 호출 미들웨어.
- MOM (Message Oriented Middleware) : 메시지 기반 비동기형 메시지를 전달하는 미들웨어. 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용됨.
- TP Monitor : 빠른 응답속도가 필요한 업무에 사용되는 트랜잭션 처리 및 감시 미들웨어. 항공기나 철도 예약 업무 등에 최적.
- ORB (Object Request Broker) : CORBA 표준 스펙을 구현한 객체지향 미들웨어. 분산 시스템 관련 표준 사용.
- WAS
- DB

### 인터페이스 구현

- 데이터 통신을 이용한 인터페이스 구현
    - 인터페이스 형식에 맞춘 데이터 포맷을 인터페이스 대상으로 전송, 수신측에서는 이를 Parsing해 해석하는 방식.
    - 주로 JSON이나 XML 형식의 데이터 포맷을 사용해 인터페이스 구현.
        - JSON (JavaScript Object Notation) : Attribute-Value Pairs로 이루어진 데이터 객체를 전달하기 위해, 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷.
        - XML (eXtensible Markup Language) : 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어. HTML의 호환성 문제와 SGML (Standard Generalized Markup Language)의 복잡성 문제를 해결하기 위해 개발됨. SGML의 간략화된 버전.
- 인터페이스 엔티티를 이용한 인터페이스 구현
    - 인터페이스가 필요한 시스템 사이에 별도의 인터페이스 엔티티로 상호 연계하는 방식.
    - 일반적으로 인터페이스 테이블을 엔티티로 활용.
    - 송,수신 인터페이스 테이블의 구조는 상황에 따라 서로 다르게 설계할 수도 있음.
- 인터페이스 보안 기능 적용
    - Sniffing 등의 보안 문제를 고려하여 인터페이스를 구현.

### 인터페이스 구현 검증

- 인터페이스 구현 검증 도구
    - xUnit : 다양한 언어를 지원하는 단위 테스트 프레임워크
    - STAF : 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
    - FitNesse : 웹 기반 테스트 프레임워크
    - NTAF : STAF의 재사용, 확장성 + FitNesse의 협업 기능. Naver의 테스트 자동화 프레임워크
    - Selenium : 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 (WA) 테스트 프레임워크
    - watir : Ruby 언어를 사용하는 애플리케이션 테스트 프레임워크
- 인터페이스 오류 발생
    - 로그 확인 : 자세한 오류 원인 및 내역 확인 가능
    - 테이블 확인 : 확인이 쉬워 관리가 용이하나, 구체적이지 않아 별도의 분석이 필요
    - 인터페이스 감시 도구 (APM) 사용 : Scouter나 Jennifer 등을 사용하여 주기적 확인