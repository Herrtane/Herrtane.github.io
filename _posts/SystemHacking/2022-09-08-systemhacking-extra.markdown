---
layout: post
title: <System Hacking> 09. 배열 인덱스 범위, 바이트코드 및 인코딩
date: 2022-09-08 14:30:23 +0900
category: System_Hacking
comments: true
---

## 배열 인덱스 범위에 대하여

내가 기억하기로는 비주얼 스튜디오에서는 배열 범위를 벗어나는 인덱스를 참조하려고 할 경우, 에러가 발생했던 것으로 기억한다. (정확하지는 않다.)

<br/>

그래서 그동안은 '배열 인덱스는 배열 범위 안에서만 사용할 수 있다'고 생각해왔는데, 충격적이게도 보안 공부를 하면서 배열 범위를 벗어나는 인덱스도 사용할 수 있다는 것을 알게되었다. **컴파일러에서는 배열 범위 제한을 생각하지 않는다는 것이다!**

<br/>

```c
char buf[0x80];

char a = buf[0x81];
```

즉, 위의 코드가 가능하다는 것이다! 실제로 메모리 상에서 해당 buf 배열 뒤에 이어지는 값을 참조하게 된다. 추후에 다시 다루겠지만, 이를 통해 stack canary의 값을 알아내는 방법도 있다.

## 바이트코드와 인코딩에 대하여

디버깅 및 익스플로잇 코드를 파이썬으로 짜다보면, 계속해서 바이트 코드 개념이 등장하고, packing과 unpacking, encode()에 대한 개념이 등장한다. 솔직히 그동안은 인코딩과 바이트코드에 대해 잘 알지 못하고 넘어갔었는데, 이번 기회에 구글링을 통해 확실하게 정리했다.

<br/>

우선, 컴퓨터가 저장할 수 있는 유일한 값은 byte이다. 그렇기때문에 컴퓨터가 읽을 수 있는 값인 byte로 변환하는 과정이 수시로 필요한데, 이 과정을 **encoding**이라고 한다. 음악을 저장하기 위해서 MP3, WAV등을 사용하여 인코딩하듯이, 또 그림을 저장하기 위해서 PNG,JPG등을 사용하여 인코딩하듯이, 텍스트 역시 ASCII, UTF-8등을 사용하여 인코딩을 해야된다. 즉, 인코딩은 다양한 미디어들을 바이트 단위로 나타내는 것이다.

<br/>

pwntool 등의 파이썬 도구를 다루다보면, b'hello' 같은 바이트 문자열을 자주 다루게 되는데, 생긴건 문자열이지만, 내부적으로는 사람이 읽기 힘든 인코딩된 바이트이다.

```python
>>> 'I am a string'.encode('ascii')
b'I am a string'

>>> 'I am a string'.encode('utf-16')
b'\xff\xfeI\x00 \x00a\x00m\x00 \x00a\x00\x00s\x00t\x00r\x00i\x00n\x00g\x00'

>>> b'I am a string'.decode('ascii')
'I am a string'
```

위의 예시 코드를 보면, ascii로 인코딩할 경우, 사람이 읽을 수 있는 것 처럼 보이지만 결국 바이트 문자열이다. utf-16으로 인코딩할 경우, 바이트 문자열의 본 모습을 보게 된다. (참고로 둘다 똑같은 바이트 문자열이다.)

<br/>

참고로, c언어의 char형은 ascii로 인코딩 된 바이트 문자이고, python에서 문자열(str)의 기본 인코딩은 utf-8이다. 그래서 printf를 실행할 경우 char* 형을 입력해주어야 하기 때문에 바이트 문자열을 입력값으로 해야 되는 것이다. (pwntool을 이용해서 payload를 작성할 때, 왜 바이트코드로 타켓 바이너리에 payload를 전송하는지 이유를 알게되었다.)

<br/>

또한, **Unicode**는 영어 뿐만 아니라, 국제적으로 전세계 언어를 모두 표시할 수 있는 표준코드이다. 글자와 코드가 1:1 매핑되어있는 '코드표'라고 이해하면 된다. utf-8은 역시 이 유니코드를 encoding하는 '방식'이다. 

## 마치며

다음 포스팅은 stack canary에 대한 정리를 할 것인데, 중간중간 산전수전 겪었던 난관들도 같이 포스팅하도록 하겠다.
