---
layout: post
title: <OS> 07. 메모리 관리 (1)
date: 2022-01-21 20:55:23 +0900
category: OS
comments: true
---

## 메모리 관리의 개념과 정책 

- 모든 프로그램은 우선 메모리에 적재되어야 실행이 가능하므로 메모리는 중요한 작업 공간임.
- 다중 프로그래밍 환경에서는 한정된 메모리를 잘 배분하는 것이 중요함.
- 메모리관리는 메모리 관리자가 담당.
- 메모리 관리자는 운영체제의 관리 모듈과 메모리 관리 장치 (MMU)가 협업하여 관리.
- 주요 정책 세가지는 아래와 같음.
1. 적재 정책 (fetch policy) : 요구적재와 예상적재
2. 배치 정책 (placement policy)
3. 대치 정책 (replacement policy) 

## 메모리의 구조와 매핑 

- 논리적 주소를 물리적 주소로 변환해주는 과정이 필요한데, 이를 MMU에서 처리하고, 이 변환 과정에서 고정분할, 동적분할, 페이징, 세그먼테이션 등의 방법이 사용됨.
- 논리적 주소와 물리적 주소를 매핑해주는 작업을 바인딩 (binding)이라고 함. 
- compiler가 원시코드를 compile하여 object file을 생성하면, linker가 이 object file에 라이브러리 파일이나 다른 object file을 결합함. 그런 다음, loader가 지정 위치에서 시작하여 메모리에 프로그램을 배치하는데, 하드웨어 구조에 따라 절대 적재 (메모리의 지정된 위치에 적재)와 교체 적재 (메모리의 여러 위치에 적재)로 나뉨.
- 바인딩은 컴파일 시간, 적재 시간, 실행 시간으로 구분할 수 있으며, 현재 운영체제 대부분은 실행 시간에 바인딩하는 방법 사용. 

## 메모리 관련 용어 

- 동적 적재 : 모든 루틴을 메모리에 적재하지 않고 교체 가능한 형태로 디스크에 저장하며, 메인 프로그램만 먼저 메모리에 적재하여 수행하는 방법. 필요할 때 원하는 루틴을 호출해서 적재함. 메모리를 효율적으로 사용할 수 있음.
- 중첩 (오버레이) : 실행하려는 프로그램이 메모리보다 클 때는 당장 필요하지 않은 프로그램의 일부는 중첩으로 설정할 수 있음. 프로그램 실행에 꼭 필요한 공통 루틴만 메모리에 저장하고, 나머지 중첩 영역에는 필요할 때 호출하는 방식. 운영체제의 지원 없이도 실행 가능함.
- 스와핑 (프로세스 교체) : 다중 프로그래밍 환경에서는 원래 프로세스는 사용자 프로그램이 끝날 때까지 메모리에 저장되는 원칙을 지켜왔으나, 여러 알고리즘과는 맞지 않는 방식때문에 수행이 완료된 프로세스는 보조기억장치로 보냈다가, 새롭게 시작하는 프로세스는 메모리에 적재하는 방식을 채택함. 실제 실행중인 프로세스를 스와핑하려면 유휴상태라는 것을 확인해야함. 

## 메모리 할당 

1. 연속 메모리 할당
2. 분산 메모리 할당 

## 연속 메모리 할당 

### 단일 프로그래밍 환경 

- 단일 프로그래밍 환경에서 연속 메모리 할당은 운영체제 상주 영역인 모니터, 사용자 프로그램이 들어있는 사용자, 사용하지 않는 미사용 으로 나뉨.
- 프로세서에 경계 레지스터를 두어 모니터 영역에 사용자가 침범하지 않도록 방지.
- 기준 레지스터는 가장 작은 물리적 주소를 저장하고, 경계 레지스터는 프로그램 영역이 저장되어 있는 크기인 논리적 주소를 저장. 

### 다중 프로그래밍 환경 

- 고정 분할 방법과 가변 분할 방법으로 나뉨.
- 고정 분할 방법 : 메모리를 여러 개의 고정된 크기로 분할, 각 분할된 메모리는 프로세스 하나를 실행 가능. 이때 물리적 주소는 분할 기준 레지스터 값에 논리적 주소를 더해서 생성. 내부단편화 (fragmentation)로 인해 낭비된 공간 발생 가능성이 존재.
- 가변 분할 방법 :  고정된 경계를 없애고 각 프로세스가 필요한 만큼 메모리를 할당. 기준 레지스터와 경계 레지스터를 사용하여 분할 영역을 나타냄. 운영체제가 메모리의 어느 부분을 사용하고 사용할 수 있는지 알 수 있는 테이블을 유지해야 함. 내부단편화보다는 외부단편화 발생 가능. 메모리 배치 방법으로는 최초적합 (first-fit), 최적적합 (best-fit), 최악적합 (worst-fit) 알고리즘이 있음.
- 최초 적합 방법 : 프로세스를 사용 가능 공간 중 충분히 큰 첫 번째 공간에 할당. 공간 활용률이 떨어질 수 있음.
- 최적 적합 방법 : 프로세스를 사용 가능 공간 중 들어갈 수 있는 가장 작은 공간에 할당. 공간 이용률은 향상될 수 있으나, 검색하는 과정에서 많은 시간이 소요될 수 있음.
- 최악 적합 방법 : 프로세스를 가장 큰 사용 가능 공간에 할당. 공간이 크기순으로 정렬되어있지 않으면 전체를 검색해야 함.
- 단편화를 해결하는 방안으로는 메모리 통합 (coalescing)과 메모리 압축 (compaction)이 있음.
- 메모리 통합 : 하나의 작업이 끝났을 때 다른 빈 공간과 인접해 있는지 점검하여 하나로 합치는 것.
- 메모리 압축 : 메모리의 내용을 적절히 움직여 사용 가능 공간을 큰 블록 하나로 만드는 것. 모든 내부 주소를 대체해야 되기 때문에 대체가 동적일 때만 가능하고, 오버헤드가 발생. 특히 작은 조각이 많을 때 더 심함. 최적의 압축 방법을 찾는 것은 어려운 작업. 압축하는 동안 시스템은 모든 일을 중지해야 함.
- 위의 방법들의 단편화 문제를 해결하기 위해 버디 시스템 (buddy system)이 고안됨. 요청받은 메모리 크기에 맞도록 큰 버퍼들을 반복적으로 이등분하여 작은 버퍼들을 만들고, 가능할 때마다 인접한 빈 버퍼들을 합치는 과정을 반복. 나눠진 버퍼를 서로 버디라고 함.