---
layout: post
title: <OS> 06. 프로세스 스케줄링 (2)
date: 2022-01-07 23:55:23 +0900
category: OS
comments: true
---

## 스케줄링 알고리즘 

### 선입선처리 스케줄링 (FCFS) 

- First Come First Served, First In First Out
- 비선점 방식
- 일괄 처리 시스템에서는 효율적, 빠른 응답을 요청하는 대화식 시스템에서는 적합하지 않음.
- 긴 프로세스가 실행되는 동안 호위 효과 (프로세서 중심 프로세스나 입출력 중심 프로세스 중 한쪽으로 치우쳐 기다리는 불균형 상태) 발생 가능. 

### 최소작업 우선 스케줄링 (SJF) 

- Shortest Job First
- 각 작업의 프로세서 실행 시간을 이용하여 프로세서가 사용 가능할 때 실행시간이 가장 짧은 작업에 할당하는 방법.
- 선점, 비선점 둘다 가능. 보통 SJF는 비선점으로 여김. 선점형 알고리즘은 context switching 때문에 반드시 비선점보다 유리하다고는 할 수 없음.
- 선점 SJF는 최소잔여 시간 우선 스케줄링 (SRTF, Shortest Remaining Time First) 라고 함.
- 장점 : 평균 대기 시간이 가장 짧음.
- 단점 : 초기의 긴 작업이 기아 상태에 놓일 우려 존재. 실행 시간 예측이 어려워 실용적이지 못함. 

### 우선순위 스케줄링 (priority scheduling) 

- SJF은 이 스케줄링의 특수 케이스로 볼 수 있음.
- 우선순위가 동일한 프로세스들은 FCFS로 처리.
- 선점, 비선점 둘다 가능.
- 우선순위 숫자가 클수록 우선순위가 높음.
- 주요 문제인 무한 정지와 기아를 해결하기 위해, 에이징이란 방법을 사용해서 오래 대기하는 프로세스들의 우선순위를 점진적으로 증가시킴. 

### 라운드 로빈 스케줄링 (round-robin scheduling) 

- 시분할 시스템을 위해 설계됨.
- 작은 단위의 시간인 규정 시간량 (time quantum) 또는 시간 할당량 (time slice)를 정의.
- 준비큐는 FIFO 큐로 되어있음. 규정 시간이 초과되면 중단된 프로세스는 준비 큐의 마지막 위치에 입력됨.
- 선점 방식.
- 규정 시간량이 매우 작으면 processor sharing이라고 하며, 이론적으로는 마치 n개의 프로세스가 실제 프로세서 속도의 1/n속도로 실행하는 것처럼 보임.
- 지나치게 규정 시간량이 작으면, context switching 이 잦아져서 오버헤드 증가. 적절한 규정 시간량 설정이 필요함. 

### 다단계 큐 스케줄링 (MLQ) 

- MultiLevel Queue
- 각 작업을 서로 다른 묶음으로 분류할 수 있을 때 사용. 예를 들면, 포그라운드와 백그라운드 태스크.
- 각 큐는 독자적인 스케줄링을 가짐. 큐 사이에는 고정된 선점 우선순위 스케줄링. 
- 각 큐는 순서대로 절대적인 우선순위를 가지므로, 큐 사이에 시간을 나눠서 사용하지 않으면 낮은 우선순위 큐에 기아 문제가 발생할 수 있음. 

### 다단계 피드백 큐 스케줄링 (MLFQ) 

- MultiLevel Feedback Queue
- MLQ는 작업이 한 큐에 고정되어서 다른 큐로 이동할 수 없으나, MLFQ는 융통성 있게 작업이 큐 사이를 이동 가능.
- 특정 큐에서 오래 기다린 프로세스를 우선순위가 높은 큐로 이동시키는 등 에이징 방법을 사용.
- 프로세서 스케줄링 중 가장 일반적임.
- 단점은 최상의 스케줄링을 정의하는 요소를 평가하는 방법이 필요하고 복잡함. 

### HRN 스케줄링 

- Highest Response-ratio Next
- SJF의 약점인 긴 작업과 짧은 작업 간의 불평등을 보완한 스케줄링.
- 비선점 방식
- 우선순위 스케줄링의 또다른 예
- 우선순위 = (서비스 받을 시간 + 대기한 시간) / (서비스 받을 시간)
- 서비스 받을 시간이 짧을 수록, 대기한 시간이 길수록 우선순위가 높음.
- 장점 : 자원을 효율적으로 활용하고 기아가 발생하지 않음.
- 단점 : 오버헤드가 높을 수 있음. (메모리와 프로세서 낭비)