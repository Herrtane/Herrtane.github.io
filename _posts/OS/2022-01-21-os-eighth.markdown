---
layout: post
title: <OS> 08. 메모리 관리 (2)
date: 2022-01-21 21:55:23 +0900
category: OS
comments: true
---

## 분산 메모리 할당 

### 페이징 

- 프로세스를 크기가 동일한 페이지로 나누고, 메인메모리도 크기가 동일한 프레임으로 나눠서 이 곳에 적재하는 방법.
- 외부 단편화가 발생하지 않음.
- 마지막 페이지에 할당된 프레임이 완전히 차지 않는 경우 내부 단편화 발생 가능성 존재.
- 프로세서가 만드는 논리적 주소는 페이지 번호와 오프셋 d으로 구성됨. 페이지 번호 p를 페이지 테이블에서 비교하여 메모리의 페이지 기준 주소 f를 도출. f + d 가 물리적 주소가 됨.
- 페이지 크기는 하드웨어로 정의. 512바이트에서 1GB사이로 대개 정의되고, 2의 n승으로 증가. 논리적 주소의 하위 n비트가 오프셋, 나머지 상위 비트가 페이지 번호가 됨.
- 예를 들어, 16비트 논리적 주소에서 페이지 크기가 1KB라면, 하위 10비트 (2^10 = 1024 = 1KB)가 오프셋이고 나머지 상위 6비트 (2^6 = 64)가 페이지 번호. 페이지 테이블을 이용한 예시는 책을 참고.
- 32비트 프로세서는 메모리를 2^32 = 4G까지 사용할 수 있음.
- 페이지 테이블은 크기가 매우 크므로 관리 방법이 중요한데, 보통은 페이지 테이블을 프로세스가 아닌 메모리에 두고, 페이지 테이블 기준 레지스터 (Page Table Base Register)로 페이지 테이블을 지시하게 함. 아래의 3가지 방법이 존재.
- 직접 매핑을 이용한 주소 변환 : 페이지 테이블 b의 기준주소를 PTBR으로부터 구하고, 페이지 번호 p와 더한 뒤 (b + p), 이에 대응하는 프레임 p'을 도출하여 p' + d를 통해 물리적 주소를 얻음.
- 연관 매핑을 이용한 주소 변환 : 직접 매핑은 메모리 엑세스가 두번 필요하나, 이 방법은 PTBR 없이 직접 연관 사상표에서 p에 대응하는 p'을 얻음. 다만, 하드웨어가 매우 비쌈. 속도는 매우 빠름.
- 연관, 직접 매핑을 결합 : 최근 사용한 페이지만 연관 레지스터에 유지하고, 연관 레지스터에 해당 페이지가 없을 때만 직접 매핑.
- 공유 페이지 : 두 프로세스에서 동시에 같은 코드를 수행할 수 있음. 이를 재진입 코드 혹은 순수 코드라고 함. 

### 세그먼테이션 

- 페이징과 유사하나, 페이징과는 다르게 크기가 일정한 페이지 프레임으로 나누지 않고, 동적 분할 방법으로 세그먼트를 나눔.
- 사용자 프로그램과 프로세스 관점의 메모리를 일치시킴.
- 세그먼트 번호, 세그먼트 오프셋 주소를 사용하여 테이블을 참조하여 세그먼트의 물리적 주소를 도출. 페이징과 메모리 엑세스 과정이 동일.
- 세그먼트도 공유 가능.
- 외부 단편화 문제는 평균 세그먼트 크기가 작으면 일반적으로 작음. 

### 페이지화된 세그먼테이션 

- 세그먼테이션의 외부 단편화를 해결하기 위해, 세그먼트를 다시 페이지로 각각 나눈것.