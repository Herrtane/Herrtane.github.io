---
layout: post
title: <OS> 09. 가상 메모리 (1)
date: 2022-01-21 21:56:23 +0900
category: OS
comments: true
---

## 가상 메모리의 개념과 원리 

- 메모리를 관리하는 또 다른 형태로, 각 프로그램에 실제 메모리 주소가 아닌 가상 메모리 주소를 주는 방법.
- 실제로는 모든 프로그램을 항상 동시에 사용하지 않고, 실제로 실행되는 코드는 표면보다 적을 가능성이 존재하므로, 프로그램의 필요한 일부만 메모리에 적재하여 수행.
- 단, 메모리와 디스크 사이 이동량이 증가하므로, 이를 효율적으로 관리할 적절한 페이징 알고리즘이 필요하고, 요구된 프로세스의 페이지가 없을 때 처리하는 방안 등이 필요.
- 메모리 공간 문제를 가상 메모리를 통해 해결하려면, 메인 메모리에서 사용하는 물리적 주소와 실행중인 프로세스가 참조하는 논리적 주소, 즉 가상 주소를 분리해야 함. 가상 주소를 물리적 주소로 변환 함수를 통해 변환하는 과정을 매핑이라고 하고, 이 과정은 빨라야함.
- 인위적으로 연속적이다 : 가상주소에서 연속적이라고 메인 메모리에서도 연속적일 필요는 없다는 의미. 즉, 사용자는 데이터의 적재 위치를 고려하지 않아도 되고, 프로그램 자체의 동작에만 관심을 집중하면 됨.
- 2단계 메모리 관리 : 메인 메모리에는 실행 중 참조하는 데이터를, 나머지는 디스크에 저장하는 방식. 

## 요구 페이징 (Demand paging) 

- 가상 메모리에서 많이 사용하는 메모리 관리 방법.
- 스와핑을 사용하는 페이징 시스템과 유사.
- 실행 중인 프로세스들의 요구 페이지만 메모리에 fetch.
- 페이지 테이블의 각 항목에 페이지의 유효 여부를 표시하는 타당 비트와 비타당 비트를 추가. 메인 메모리에 있는지 없는지.
- 페이지 부재 (page fault) : 프로그램이 메모리에 저장되지 않은 페이지를 사용하려고 할 때 하드웨어가 제기하는 소프트웨어 트랩. 즉, 비타당 비트로 표시된 페이지에 접근할 때, 빈 프레임 중 하나를 선택해서 디스크에서 요구된 페이지를 적재하고, 타당 비트로 변경.
- 메인 메모리와 디스크 간의 과도한 페이지 교체로 오버헤드를 증가시킬 우려가 있음.
- 적재된 페이지 중 하나를 수정할 때까지 페이지들은 여러 프로그램이 공유하므로 쓰기복사 (Copy-On-Wirte) 기술로 더 많은 자원 저장 가능. 

## 페이지 대치 알고리즘 

- 페이지 부재가 발생하면, 메인 메모리에 있으면서 사용하지 않는 페이지를 없애 새로운 페이지로 바꿈.
- 요구 페이징의 기본 요소이며, 논리적 공간과 실제 메모리 공간을 완벽하게 분리하므로 작은 실제 메모리에서 매우 큰 가상 메모리를 제공할 수 있음.
- 일반적으로 프레임 수와 페이지 부재는 반비례. 단, 이와 반대되는 현상이 발생할 수 있는데, 이를 Belady's anomaly라고 함. 

### 선입선출 대치 알고리즘 (FIFO) 

- 가장 오래된 페이지부터 우선 대치됨.
- 큐의 크기는 사용 가능한 메모리 프레임의 수. 

### 최적 페이지 대치 알고리즘 (OPT) 

- OPTimal replacement algorithm
- Belady's anomaly를 해결하기 위해 고안된 알고리즘. 모든 알고리즘 중 페이지 부재 비율이 가장 낮음.
- 앞으로 가장 오랫동안 사용하지 않을 페이지를 대치. 즉, 페이지 대치를 해야할 때, 현재 프레임 중에 가장 먼 미래에 다시 참조될 페이지를 대치함.
- SJF와 마찬가지로 구현하기가 어려움. 

### 최근 최소 사용 대치 알고리즘 (LRU) 

- Least Recently Used replacement algorithm
- 프로세스가 가장 최근의 페이지에 액세스했다는 것은 머지 않아 다시 액세스할 가능성이 있다는 의미.
- 과거 오랫동안 사용하지 않은 페이지를 대치. 즉, 과거의 데이터를 이용하여 미래를 예측하려는 통계적 개념.
- OPT를 사용하는 것이 불가할 때 사용할 수 있는 알고리즘.
- 알고리즘을 구현하는 하드웨어가 별도로 필요함. 
- 첫번째 하드웨어 : 카운터를 이용하여, 각 페이지 테이블 항목에 사용 시간 레지스터를 연관시키고, 페이지 참조가 있을 때마다 클록이 증가하여, 클록 수가 가장 작은 페이지는 대치됨.
- 두번째 하드웨어 : 페이지 번호를 스택에 넣어 관리. 페이지를 참조할 때마다 스택의 top에 두어 순서를 결정. bottom의 페이지 번호가 가장 늦게 사용한 페이지가 되므로, 대치 우선순위 페이지가 됨. 단, 스택의 중간에서 항목을 가져오므로 double linked list로 구현해야 됨. 

### 최근 최소 사용 근접 알고리즘 

- 하드웨어를 지원하지 않는 경우, 유사한 알고리즘을 사용.
- 참조 비트 알고리즘 : 각 페이지마다 8비트 시프트 레지스터를 사용하여, 최근 여덟 번의 기간 동안 사용한 페이지 기록 정보를 유지. unsigned int로 해석하면, 값이 가장 작은 페이지가 대치 대상임. 단, 희생자가 둘 이상인 경우 모두 희생자로 처리하거나, FIFO로 하나를 선택.
- 시계 알고리즘 (2차적 기회 대치 알고리즘) : FIFO 기반의 알고리즘이나, 가장 오랫동안 메인 메모리에 있던 페이지 중 자주 사용하는 페이지의 대치를 방지하려는 알고리즘. 각 프레임의 사용 여부를 나타내는 참조 비트를 추가, 참조할 때마다 다시 1로 설정. 프레임 포인터가 한바퀴 돌면서, 처음 만나는 참조 비트가 0인 프레임이 대치 대상.
- NUR (Not Used Recently) 알고리즘 : (참조비트, 수정비트)를 추가하여, (0,0), (0,1), (1,0), (1,1) 순으로 대치됨.
- 최소 사용 빈도수 알고리즘 (Least Frequently Used) : 각 페이지마다 참조 횟수 카운터가 있으며, 수가 가장 작은 페이지를 대치.
- 최대 사용 빈도수 알고리즘 (Most Frequently Used) : 계수가 가장 작은 페이지는 앞으로 사용할 확률이 높다고 판단하여 대치 후보에서 제외. 

### 페이지 버퍼링 

- 대치 알고리즘들의 성능 저하를 막기 위해, 교체 대상으로 선택한 페이지를 즉시 교체하지 않은 채 잠시 동안 메인 메모리에 유지.