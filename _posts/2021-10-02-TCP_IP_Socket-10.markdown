---
layout: post
title: <TCP/IP Socket> 12. 다중접속 서버 - 멀티플렉싱 기반
date: 2021-10-02 15:50:23 +0900
category: TCP/IP_Socket
comments: true
---

## 멀티플렉싱

멀티프로세스는 오버헤드가 적지 않은 방법임은 쉽게 알 수 있다. 멀티플렉싱은 통신채널을 최소한으로 줄여서 최대한의 데이터를 전달하기 위해 사용되는 기술이다. 이를 클라이언트 - 서버 개념에 적용한다면, 접속해있는 클라이언트의 수에 상관없이, 서비스를 제공하는 프로세스의 수는 오로지 하나이다. 윈도우와 리눅스 공용으로 사용되는 멀티플렉싱 기법은 select() 함수를 사용하는 방법이 대표적이다.

## select()

select() 함수를 사용하면 여러 개의 파일 디스크립터를 모아서 한꺼번에 관찰하면서, 어느 디스크립터에 변화가 생겼는지 그 여부를 확인할 수 있다. 이 **파일 디스크립터의 묶음을 fd_set형 변수**라고 한다. 0과 1로 이루어진 비트 단위의 배열이며, 왼쪽부터 파일 디스크립터 0부터 순서대로 커지면서 저장된다. 아래의 매크로 함수들로 이 fd_set형 변수를 조작한다.

```c
fd_set set;

FD_ZERO(&set);      // 모든 비트를 0으로 초기화
FD_SET(1, &set);    // 첫번째 인자로 전달된 파일 디스크립터(여기서는 파일 디스크립터 1)를 fd_set에 등록한다. (0에서 1로 비트를 변환)
FD_CLR(2, &set);    // 첫번째 인자로 전달된 파일 디스크립터(여기서는 파일 디스크립터 2)를 fd_set에서 해당하는 정보를 삭제한다. (1에서 0으로 비트를 변환)
```

다음으로 select() 함수를 보이겠다.

```c
#include <sys/select.h>
#include <sys/time.h>

int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);

struct timeval{
    long tv_sec;
    long tv_usec;
}
```

첫번째 인자는 파일 디스크립터의 관찰 범위이다. 파일 디스크립터의 값은 생성될 때마다 1씩 증가하기 때문에 가장 큰 파일 디스크립터의 값에 1을 더해서 인자로 전달한다. 마지막 인자는 타임아웃 인자이다. select() 함수는 관찰중인 파일 디스크립터에 변화가 생겨야 반환을 하므로, 그 전에는 블로킹 상태에 빠진다. 이를 방지해주는 역할이다. select() 함수 호출 이후 0이 아닌 양수가 반환이 되면, 그 수 만큼 파일 디스크립터에 변화가 발생했다는 뜻이다. **select() 함수 호출 이후에는 1로 설정된 모든 비트가 다 0으로 변경되지만, 변화가 발생한 파일 디스크립터에 해당하는 비트는 1로 남아있게 되고, 이 남아있는 비트를 확인해서 어떤 파일 디스크립터에 변화가 생겼는지 확인하는 방식**을 사용한다.

## 마치며

역시 자세한 서버 구현 코드는 처음 포스팅한 github 링크를 참고하기 바란다.